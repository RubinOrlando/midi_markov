#!/usr/bin/env ruby

require 'midilib'
require 'set'
require 'find'
require 'optparse'
require 'pry'


OPTIONS = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: midi_markov [options] {midi_file_path}'

  opts.on('--midi-path [FILE]', String, 'Path of MIDI file or directory to recursively search for MIDI files for training the Markov model') do |f|
    OPTIONS[:midi_path] = f
  end

  opts.on('--length [LENGTH]', Integer, 'Length of the generated piece') do |l|
    OPTIONS[:length] = l
  end

  opts.on('--min-sequence [MIN_SEQUENCE]', Integer, 'Specify minimum lenght of identical sequence') do |m|
    OPTIONS[:min_sequence] = m
  end

  opts.on('--match-delta', 'Require generated notes to have consecutive delta_times as well as note values') do
    OPTIONS[:match_delta] = true
  end

  opts.on('--rand-seed [RAND_SEED]', Integer, 'Specify the seed used in the randomization of the generated pieces (to reproduce the exact same midi)') do |r|
    OPTIONS[:rand_seed] = r
  end

  opts.on('--on-delta [ON_DELTA]', Integer, 'This value will be used for the delta_time value of each \'on\' note.  If not provided, delta_time values will be derived from source notes.') do |d|
    OPTIONS[:on_delta] = d
  end

  opts.on('--off-delta [OFF_DELTA]', Integer, 'This value will be used for the delta_time value of each \'off\' note.  If not provided, delta_time values will be derived from source notes.') do |d|
    OPTIONS[:off_delta] = d
  end

  opts.on('--drone', 'Introduce a little bug that makes things drone-y') do
    OPTIONS[:drone] = true
  end
end.parse!

OPTIONS[:midi_path] ||= './midi_files'
OPTIONS[:length] ||= 8 * 32
OPTIONS[:min_sequence] ||= 2
OPTIONS[:rand_seed] ||= rand(10_000)

puts "Using rand-seed value of #{OPTIONS[:rand_seed]}"

# allow deterministic sampling
class Array
  R = OPTIONS[:rand_seed] ? Random.new(OPTIONS[:rand_seed]) : Random.new

  def sample
    self[R.rand(length)]
  end
end

# Group simultaneous notes together to use as a key in a markov map
class MidiEventGroup
  attr_accessor :midi_events, :notes, :delta_times

  def initialize(midi_events=[])
    @midi_events = midi_events
    @notes = midi_events.collect(&:note)
    @delta_times = midi_events.collect(&:off).collect(&:delta_time)
  end

  def eql?(other_event_group)
    self.class == other_event_group.class && self.notes == other_event_group.notes &&
      (!OPTIONS[:match_delta] || self.delta_times == other_event_group.delta_times)
  end

  def hash
    @notes.hash + (OPTIONS[:match_delta] ? (13 * @delta_times.hash) : 0)
  end

  def <<(midi_event)
    @midi_events ||= []
    @midi_events << midi_event
    @notes ||= Set.new
    @notes << midi_event.note
    @delta_times << midi_event.off.delta_time
  end

  def to_s
    @notes.to_s
  end
end


def add_to_markov_map(markov_map, sequence)
  events_starting_at = {}
  sequence.each do |track|
    track.each do |event|
      if MIDI::NoteOnEvent === event
        start_time = event.time_from_start
        events_starting_at[start_time] ||= MidiEventGroup.new
        events_starting_at[start_time] << event
      end
    end
  end

  ordered_events = events_starting_at.values

  ordered_events.each_cons(OPTIONS[:min_sequence] + 1).each_with_index do |events, i|
    key = events[0...-1]
    markov_map[key] ||= []
    markov_map[key] << events[-1]
  end
end

def on_and_off_events(midi_events)
  # Temporary! Make all notes of equal length and create matching end events
  on_events = midi_events.collect do |midi_event|
    MIDI::NoteOnEvent.new(OPTIONS[:drone] ? midi_event.delta_time : 0,
      midi_event.note, midi_event.velocity, OPTIONS[:on_delta] || midi_event.delta_time)
  end

  off_events = midi_events.collect do |midi_event|
    MIDI::NoteOffEvent.new(OPTIONS[:drone] ? midi_event.off.delta_time : 0,
      midi_event.note, midi_event.off.velocity, OPTIONS[:off_delta] || midi_event.off.delta_time)
  end

  on_events + off_events
end

def generate_markov_map(midi_files)
  markov_map = {}
  midi_files.each do |midi_file|
    sequence = MIDI::Sequence.new
    File.open(midi_file, 'rb') { |f| sequence.read(f) }
    add_to_markov_map(markov_map, sequence)
  end

  puts markov_map.values.collect(&:size).max
  markov_map
end

def generate_sequence(markov_map, num_steps)
  sequence = MIDI::Sequence.new
  track = MIDI::Track.new(sequence)

  # seed
  previous_event_groups = markov_map.keys.sample
  track.events += on_and_off_events(previous_event_groups.sample.midi_events)
  
  num_steps.times do
    next_event_group_candidates = markov_map[previous_event_groups]
    break unless next_event_group_candidates && !next_event_group_candidates.empty?
    next_event_group = next_event_group_candidates.sample

    previous_event_groups.shift # rolling window of 'min_sequence' events as key
    previous_event_groups << next_event_group

    track.events += on_and_off_events(next_event_group.midi_events)
  end
  
  track.recalc_times
  sequence.tracks << track

  sequence
end

#===================================================================================
input_midi_files = if File.directory?(OPTIONS[:midi_path])
  Find.find(OPTIONS[:midi_path]).select { |f| File.directory?(f) ? nil : f }.compact
else
  [OPTIONS[:midi_path]]
end

markov_map = generate_markov_map(input_midi_files)
sequence = generate_sequence(markov_map, OPTIONS[:length])
File.open('markov.mid', 'wb') { | file | sequence.write(file) }
`timidity markov.mid 2> /dev/null`
