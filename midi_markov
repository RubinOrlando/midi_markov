#!/usr/bin/env ruby

require 'midilib'
require 'set'
require 'find'
require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: midi_markov [options] {midi_file_path}'

  opts.on('--min-sequence', :numeric, 'Specify minimum lenght of identical sequence') do |m|
    options[:min_sequence] = m
  end
end.parse!

midi_file_path = ARGV[0]
input_midi_files = if File.directory?(midi_file_path)
  Find.find(midi_file_path).select { |f| File.directory?(f) ? nil : f }.compact
else
  [midi_file_path]
end

# Group simultaneous notes together to use as a key in a markov map
class Events
  attr_accessor :events, :notes

  def initialize(events=[])
    @events = events
    @notes = events.collect(&:note)
  end

  def eql?(other_events)
    other_events.class == self.class && other_events.notes == other_events.notes
  end

  def hash
    notes.hash
  end

  def <<(event)
    @events ||= []
    @events << event
    @notes ||= Set.new
    @notes << event.note
  end

  def to_s
    notes.to_s
  end
end


def add_to_markov_map(markov_map, sequence)
  events_starting_at = {}
  sequence.each do |track|
    track.each do |event|
      if MIDI::NoteOnEvent === event
        start_time = event.time_from_start
        events_starting_at[start_time] ||= Events.new
        events_starting_at[start_time] << event
      end
    end
  end

  ordered_events = events_starting_at.values

  ordered_events.each_with_index do |events, i|
    if i < ordered_events.size
      markov_map[events] ||= []
      markov_map[events] << ordered_events[i + 1]
    end
  end
end

def on_and_off_events(events)
  # Temporary! Make all notes of equal length and create matching end events
  on_events = events.collect do |event|
    MIDI::NoteOnEvent.new(0, event.note, event.velocity, 0)
  end

  off_events = events.collect do |event|
    MIDI::NoteOffEvent.new(0, event.note, event.velocity, 0)
  end

  off_events.first.delta_time = 120

  on_events + off_events
end

def generate_markov_map(midi_files)
  markov_map = {}
  midi_files.each do |midi_file|
    sequence = MIDI::Sequence.new
    File.open(midi_file, 'rb') { |f| sequence.read(f) }
    add_to_markov_map(markov_map, sequence)
  end

  markov_map
end

def generate_sequence(markov_map, num_steps)
  sequence = MIDI::Sequence.new
  track = MIDI::Track.new(sequence)

  previous_events = markov_map.keys.first
  track.events += on_and_off_events(previous_events.events) # seed
  
  num_steps.times do
    next_events = markov_map[previous_events].sample
    next unless markov_map[next_events] # don't jump to the last note
    break unless next_events
  
    track.events += on_and_off_events(next_events.events)
  
    previous_events = next_events
  end
  
  track.recalc_times
  sequence.tracks << track

  sequence
end


markov_map = generate_markov_map(input_midi_files)
sequence = generate_sequence(markov_map, 8 * 64)

File.open('markov.mid', 'wb') { | file | sequence.write(file) }

`timidity markov.mid`
