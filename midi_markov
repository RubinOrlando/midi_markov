#!/usr/bin/env ruby

require 'midilib'
require 'set'
require 'find'
require 'optparse'
require 'pry'


OPTIONS = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: midi_markov [options] {midi_file_path}'

  opts.on('--min-sequence [MIN_SEQUENCE]', Integer, 'Specify minimum lenght of identical sequence') do |m|
    OPTIONS[:min_sequence] = m
  end

  opts.on('--rand-seed [RAND_SEED]', Integer, 'Specify the seed used in the randomization of the generated pieces (to reproduce the exact same midi)') do |r|
    OPTIONS[:rand_seed] = r
  end
end.parse!

OPTIONS[:min_sequence] ||= 1
OPTIONS[:rand_seed] ||= rand(1000)

puts "Using rand-seed value of #{OPTIONS[:rand_seed]}"

# allow deterministic sampling
class Array
  R = OPTIONS[:rand_seed] ? Random.new(OPTIONS[:rand_seed]) : Random.new

  def sample
    self[R.rand(length)]
  end
end


midi_file_path = ARGV[0]
input_midi_files = if File.directory?(midi_file_path)
  Find.find(midi_file_path).select { |f| File.directory?(f) ? nil : f }.compact
else
  [midi_file_path]
end

# Group simultaneous notes together to use as a key in a markov map
class Events
  attr_accessor :events, :notes

  def initialize(events=[])
    @events = events
    @notes = events.collect(&:note)
  end

  def eql?(other_events)
    other_events.class == self.class && other_events.notes == other_events.notes
  end

  def hash
    notes.hash
  end

  def <<(event)
    @events ||= []
    @events << event
    @notes ||= Set.new
    @notes << event.note
  end

  def to_s
    notes.to_s
  end
end


def add_to_markov_map(markov_map, sequence)
  events_starting_at = {}
  sequence.each do |track|
    track.each do |event|
      if MIDI::NoteOnEvent === event
        start_time = event.time_from_start
        events_starting_at[start_time] ||= Events.new
        events_starting_at[start_time] << event
      end
    end
  end

  ordered_events = events_starting_at.values

  ordered_events.each_cons(OPTIONS[:min_sequence] + 1).each_with_index do |events, i|
    key = events[0...-1]
    markov_map[key] ||= []
    markov_map[key] << events[-1]
  end
end

def on_and_off_events(events)
  # Temporary! Make all notes of equal length and create matching end events
  on_events = events.collect do |event|
    MIDI::NoteOnEvent.new(event.delta_time, event.note, event.velocity, 0)
  end

  off_events = events.collect do |event|
    MIDI::NoteOffEvent.new(event.off.delta_time, event.note, event.off.velocity, 0)
  end

  on_events + off_events
end

def generate_markov_map(midi_files)
  markov_map = {}
  midi_files.each do |midi_file|
    sequence = MIDI::Sequence.new
    File.open(midi_file, 'rb') { |f| sequence.read(f) }
    add_to_markov_map(markov_map, sequence)
  end

#  puts markov_map.values.collect(&:size).max
  markov_map
end

def generate_sequence(markov_map, num_steps)
  sequence = MIDI::Sequence.new
  track = MIDI::Track.new(sequence)

  # seed
  previous_events_set = markov_map.keys.sample
  track.events += on_and_off_events(previous_events_set.sample.events)
  
  num_steps.times do
    next_events_list = markov_map[previous_events_set]
    break unless next_events_list && !next_events_list.empty?
    next_events = next_events_list.sample

    previous_events_set.shift # rolling window of 'min_sequence' events as key
    previous_events_set << next_events

    track.events += on_and_off_events(next_events.events)
  end
  
  track.recalc_times
  sequence.tracks << track

  sequence
end

Random.new_seed

markov_map = generate_markov_map(input_midi_files)
sequence = generate_sequence(markov_map, 8 * 32)

File.open('markov.mid', 'wb') { | file | sequence.write(file) }

`timidity markov.mid 2> /dev/null`
