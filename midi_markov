#!/usr/bin/env ruby

require 'midilib'
require 'set'

puts 'Usage: midi_markov.rb {midi_file_path}' unless ARGV.size == 1

midi_file_path = ARGV[0]
puts midi_file_path

input_sequence = MIDI::Sequence.new
File.open(midi_file_path, 'rb') { | file | input_sequence.read(file) }


# Group simultaneous notes together to use as a key in a markov map
class Events
  attr_accessor :events, :notes

  def initialize(events=[])
    @events = events
    @notes = events.collect(&:note)
  end

  def eql?(other_events)
    other_events.class == self.class && other_events.notes == other_events.notes
  end

  def hash
    notes.hash
  end

  def <<(event)
    @events ||= []
    @events << event
    @notes ||= Set.new
    @notes << event.note
  end

  def to_s
    notes.to_s
  end
end


def generate_markov_map(sequence)
  events_starting_at = {}
  sequence.each do |track|
    track.each do |event|
      if MIDI::NoteEvent === event
        start_time = event.time_from_start
        events_starting_at[start_time] ||= Events.new
        events_starting_at[start_time] << event
      end
    end
  end

  ordered_events = events_starting_at.values

  markov_map = {}
  ordered_events.each_with_index do |events, i|
    if i < ordered_events.size
      markov_map[events] ||= []
      markov_map[events] << ordered_events[i + 1]
    end
  end

  markov_map
end

markov_map = generate_markov_map(input_sequence)

# markov_map.each do |k, v|
#   puts k
#   puts v.events.size
# end

# output_sequence = MIDI::Sequence.new
# output_sequence.tracks = input_sequence.collect do |input_track|
#   output_track = MIDI::Track.new(output_sequence)
#   output_track.events = input_track.collect do |input_event|
#     input_event
#   end

#   output_track
# end

# File.open('markov.mid', 'wb') { | file | output_sequence.write(file) }
