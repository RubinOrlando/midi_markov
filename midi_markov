#!/usr/bin/env ruby

require 'midilib'
require 'set'
require 'find'

puts 'Usage: midi_markov.rb {midi_file_path}' unless ARGV.size == 1

midi_file_path = ARGV[0]
puts midi_file_path


# Group simultaneous notes together to use as a key in a markov map
class Events
  attr_accessor :events, :notes

  def initialize(events=[])
    @events = events
    @notes = events.collect(&:note)
  end

  def eql?(other_events)
    other_events.class == self.class && other_events.notes == other_events.notes
  end

  def hash
    notes.hash
  end

  def <<(event)
    @events ||= []
    @events << event
    @notes ||= Set.new
    @notes << event.note
  end

  def to_s
    notes.to_s
  end
end


def add_to_markov_map(markov_map, sequence)
  events_starting_at = {}
  sequence.each do |track|
    track.each do |event|
      if MIDI::NoteOnEvent === event
        start_time = event.time_from_start
        events_starting_at[start_time] ||= Events.new
        events_starting_at[start_time] << event
      end
    end
  end

  ordered_events = events_starting_at.values

  ordered_events.each_with_index do |events, i|
    if i < ordered_events.size
      markov_map[events] ||= []
      markov_map[events] << ordered_events[i + 1]
    end
  end
end


markov_map = {}
input_midi_files = if File.directory?(midi_file_path)
  Find.find(midi_file_path).select do |f|
    File.directory?(f) ? nil : f
  end.compact
else
  [midi_file_path]
end

input_midi_files.each do |input_midi_file|
  input_sequence = MIDI::Sequence.new
  File.open(input_midi_file, 'rb') { |f| input_sequence.read(f) }
  add_to_markov_map(markov_map, input_sequence)
end

NUM_STEPS = 8 * 32

output_sequence = MIDI::Sequence.new
track = MIDI::Track.new(output_sequence)
last_events = markov_map.keys.first
track.events += last_events.events # seed

NUM_STEPS.times do
  next_events = markov_map[last_events].sample
  next unless markov_map[next_events] # don't jump to the last note
  break unless next_events

  # Temporary! Make all notes of equal length and create matching end events
  next_events.events.each do |event|
    event.delta_time = 0
  end

  end_events = next_events.events.collect do |event|
    MIDI::NoteOffEvent.new(0, event.note, event.velocity, 0)
  end

  end_events.first.delta_time = 120

  track.events += next_events.events
  track.events += end_events

  last_events = next_events
end

track.recalc_times
output_sequence.tracks << track

File.open('markov.mid', 'wb') { | file | output_sequence.write(file) }
`timidity markov.mid`
